<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockCraft VIP - Premium Voxel Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            overflow: hidden;
            cursor: none;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 50%, #E0F6FF 100%);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: default;
        }

        .logo {
            font-size: 72px;
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6347);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
        }

        .vip-badge {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            color: #000;
            margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        #startBtn {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #startBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(76, 175, 80, 0.6);
        }

        .features {
            margin-top: 40px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 600px;
        }

        .feature {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            color: white;
        }

        .feature-icon {
            font-size: 32px;
            margin-bottom: 5px;
        }

        .feature-text {
            font-size: 14px;
            opacity: 0.9;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        #crosshair::before {
            width: 3px;
            height: 24px;
            left: 10.5px;
        }

        #crosshair::after {
            width: 24px;
            height: 3px;
            top: 10.5px;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .hud-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hud-label {
            opacity: 0.7;
            min-width: 80px;
        }

        .hud-value {
            font-weight: bold;
            color: #4CAF50;
        }

        #hotbar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            pointer-events: all;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .hotbar-slot {
            width: 70px;
            height: 70px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .hotbar-slot:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
        }

        .hotbar-slot.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), inset 0 0 20px rgba(255, 215, 0, 0.2);
        }

        .slot-icon {
            font-size: 36px;
        }

        .slot-count {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .slot-key {
            position: absolute;
            top: 4px;
            left: 6px;
            font-size: 10px;
            opacity: 0.6;
            color: white;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            max-width: 250px;
        }

        #controls h3 {
            margin-bottom: 10px;
            color: #FFD700;
            font-size: 14px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
        }

        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
        }

        #tooltip {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #tooltip.visible {
            opacity: 1;
        }

        #dayNightCycle {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .time-icon {
            font-size: 24px;
        }

        #blockBreakProgress {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            overflow: hidden;
            display: none;
        }

        #blockBreakProgress.active {
            display: block;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.1s linear;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            animation: particleFloat 1s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0.5);
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="startScreen">
        <div class="logo">‚õèÔ∏è BLOCKCRAFT VIP</div>
        <div class="vip-badge">‚ú® PREMIUM EDITION ‚ú®</div>
        <button id="startBtn">START GAME</button>

        <div class="features">
            <div class="feature">
                <div class="feature-icon">üåç</div>
                <div class="feature-text">Infinite Procedural World</div>
            </div>
            <div class="feature">
                <div class="feature-icon">üé®</div>
                <div class="feature-text">Multiple Biomes</div>
            </div>
            <div class="feature">
                <div class="feature-icon">üåì</div>
                <div class="feature-text">Day/Night Cycle</div>
            </div>
            <div class="feature">
                <div class="feature-icon">‚ö°</div>
                <div class="feature-text">Smooth Performance</div>
            </div>
        </div>
    </div>

    <div id="ui">
        <div id="crosshair"></div>

        <div id="hud">
            <div class="hud-item">
                <span class="hud-label">Position:</span>
                <span class="hud-value" id="position">0, 0, 0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Looking at:</span>
                <span class="hud-value" id="lookingAt">Sky</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">FPS:</span>
                <span class="hud-value" id="fps">60</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Blocks:</span>
                <span class="hud-value" id="blockCount">0</span>
            </div>
        </div>

        <div id="dayNightCycle">
            <span class="time-icon" id="timeIcon">‚òÄÔ∏è</span>
            <span id="timeDisplay">Day 1 - 06:00</span>
        </div>

        <div id="controls">
            <h3>‚å®Ô∏è CONTROLS</h3>
            <div class="control-item">
                <span>Move</span>
                <span class="control-key">WASD</span>
            </div>
            <div class="control-item">
                <span>Jump</span>
                <span class="control-key">SPACE</span>
            </div>
            <div class="control-item">
                <span>Fly Up</span>
                <span class="control-key">SPACE</span>
            </div>
            <div class="control-item">
                <span>Fly Down</span>
                <span class="control-key">SHIFT</span>
            </div>
            <div class="control-item">
                <span>Break Block</span>
                <span class="control-key">LEFT CLICK</span>
            </div>
            <div class="control-item">
                <span>Place Block</span>
                <span class="control-key">RIGHT CLICK</span>
            </div>
            <div class="control-item">
                <span>Select Block</span>
                <span class="control-key">1-8</span>
            </div>
            <div class="control-item">
                <span>Sprint</span>
                <span class="control-key">W + W</span>
            </div>
        </div>

        <div id="hotbar"></div>

        <div id="tooltip"></div>

        <div id="blockBreakProgress">
            <div class="progress-bar"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Block types with enhanced properties
        const BLOCKS = {
            AIR: { id: 0, name: 'Air', icon: 'üí®', color: null, hardness: 0 },
            GRASS: { id: 1, name: 'Grass Block', icon: 'üü©', color: '#7CB342', topColor: '#8BC34A', sideColor: '#6D8B3E', hardness: 0.6 },
            DIRT: { id: 2, name: 'Dirt', icon: 'üü´', color: '#8D6E63', topColor: '#8D6E63', sideColor: '#7A5E55', hardness: 0.5 },
            STONE: { id: 3, name: 'Stone', icon: '‚¨ú', color: '#78909C', topColor: '#78909C', sideColor: '#607D8B', hardness: 1.5 },
            WOOD: { id: 4, name: 'Oak Log', icon: 'üü§', color: '#795548', topColor: '#6D4C41', sideColor: '#5D4037', hardness: 2 },
            LEAVES: { id: 5, name: 'Oak Leaves', icon: 'üü¢', color: '#66BB6A', topColor: '#66BB6A', sideColor: '#558B59', hardness: 0.2 },
            SAND: { id: 6, name: 'Sand', icon: 'üü°', color: '#FFD54F', topColor: '#FFD54F', sideColor: '#FFC83D', hardness: 0.5 },
            WATER: { id: 7, name: 'Water', icon: 'üíß', color: '#42A5F5', topColor: '#42A5F5', sideColor: '#1E88E5', hardness: 999 },
            PLANKS: { id: 8, name: 'Oak Planks', icon: 'ü™µ', color: '#BCAAA4', topColor: '#BCAAA4', sideColor: '#A1887F', hardness: 2 },
            COBBLE: { id: 9, name: 'Cobblestone', icon: 'üîò', color: '#607D8B', topColor: '#607D8B', sideColor: '#546E7A', hardness: 2 },
            COAL_ORE: { id: 10, name: 'Coal Ore', icon: '‚ö´', color: '#424242', topColor: '#424242', sideColor: '#212121', hardness: 3 },
            IRON_ORE: { id: 11, name: 'Iron Ore', icon: 'üî∂', color: '#D7CCC8', topColor: '#D7CCC8', sideColor: '#BCAAA4', hardness: 3 }
        };

        // Game state
        const game = {
            world: {},
            chunks: {},
            player: {
                x: 0,
                y: 30,
                z: 0,
                vx: 0,
                vy: 0,
                vz: 0,
                yaw: 0,
                pitch: 0,
                onGround: false,
                selectedSlot: 0,
                sprinting: false,
                lastWPress: 0
            },
            time: 0,
            dayLength: 1200, // 20 minutes per day
            keys: {},
            mouse: { locked: false },
            renderDistance: 16,
            chunkSize: 16,
            inventory: {},
            breakingBlock: null,
            breakProgress: 0,
            particles: []
        };

        // Initialize inventory
        Object.values(BLOCKS).forEach(block => {
            if (block.id > 0 && block.id <= 11) {
                game.inventory[block.id] = block.id <= 6 ? 999 : 0;
            }
        });

        // Perlin-like noise for terrain
        class SimplexNoise {
            constructor(seed = Date.now()) {
                this.seed = seed;
            }

            noise(x, z) {
                const X = Math.floor(x) & 255;
                const Z = Math.floor(z) & 255;

                x -= Math.floor(x);
                z -= Math.floor(z);

                const u = this.fade(x);
                const v = this.fade(z);

                const a = this.p[X] + Z;
                const b = this.p[X + 1] + Z;

                return this.lerp(v,
                    this.lerp(u, this.grad(this.p[a], x, z), this.grad(this.p[b], x - 1, z)),
                    this.lerp(u, this.grad(this.p[a + 1], x, z - 1), this.grad(this.p[b + 1], x - 1, z - 1))
                );
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, z) {
                const h = hash & 15;
                const u = h < 8 ? x : z;
                const v = h < 4 ? z : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            p = [];
        }

        // Initialize permutation table
        const noise = new SimplexNoise();
        noise.p = new Array(512);
        for (let i = 0; i < 256; i++) {
            noise.p[i] = noise.p[i + 256] = Math.floor(Math.random() * 256);
        }

        // World generation
        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (game.chunks[key]) return;

            game.chunks[key] = true;

            const startX = chunkX * game.chunkSize;
            const startZ = chunkZ * game.chunkSize;

            for (let x = startX; x < startX + game.chunkSize; x++) {
                for (let z = startZ; z < startZ + game.chunkSize; z++) {
                    // Multi-octave noise for varied terrain
                    let height = 0;
                    let amplitude = 15;
                    let frequency = 0.02;

                    for (let i = 0; i < 4; i++) {
                        height += noise.noise(x * frequency, z * frequency) * amplitude;
                        amplitude *= 0.5;
                        frequency *= 2;
                    }

                    height = Math.floor(15 + height);

                    // Determine biome
                    const temp = noise.noise(x * 0.01, z * 0.01);
                    const moisture = noise.noise(x * 0.01 + 1000, z * 0.01 + 1000);

                    for (let y = 0; y <= height; y++) {
                        let blockType;

                        if (y === height) {
                            if (y <= 12) {
                                blockType = BLOCKS.SAND.id; // Beach
                            } else if (temp > 0.3) {
                                blockType = BLOCKS.GRASS.id; // Plains
                            } else {
                                blockType = BLOCKS.GRASS.id;
                            }
                        } else if (y > height - 4) {
                            blockType = BLOCKS.DIRT.id;
                        } else {
                            blockType = BLOCKS.STONE.id;

                            // Add ores
                            if (y < height - 4 && Math.random() < 0.02) {
                                if (y < 20 && Math.random() < 0.3) {
                                    blockType = BLOCKS.COAL_ORE.id;
                                } else if (y < 15 && Math.random() < 0.15) {
                                    blockType = BLOCKS.IRON_ORE.id;
                                }
                            }
                        }

                        setBlock(x, y, z, blockType);
                    }

                    // Water level
                    if (height < 12) {
                        for (let y = height + 1; y <= 12; y++) {
                            setBlock(x, y, z, BLOCKS.WATER.id);
                        }
                    }

                    // Trees
                    if (height > 12 && height < 25 && Math.random() > 0.98) {
                        generateTree(x, height + 1, z);
                    }
                }
            }
        }

        function generateTree(x, y, z) {
            const height = 5 + Math.floor(Math.random() * 2);

            // Trunk
            for (let i = 0; i < height; i++) {
                setBlock(x, y + i, z, BLOCKS.WOOD.id);
            }

            // Leaves
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = height - 2; dy <= height + 1; dy++) {
                        const dist = Math.abs(dx) + Math.abs(dz) + Math.abs(dy - height);
                        if (dist < 5 && Math.random() > 0.3) {
                            const block = getBlock(x + dx, y + dy, z + dz);
                            if (block === BLOCKS.AIR.id) {
                                setBlock(x + dx, y + dy, z + dz, BLOCKS.LEAVES.id);
                            }
                        }
                    }
                }
            }
        }

        function setBlock(x, y, z, type) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if (type === BLOCKS.AIR.id) {
                delete game.world[key];
            } else {
                game.world[key] = type;
            }
        }

        function getBlock(x, y, z) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            return game.world[key] || BLOCKS.AIR.id;
        }

        function getBlockByPos(pos) {
            return Object.values(BLOCKS).find(b => b.id === getBlock(pos.x, pos.y, pos.z)) || BLOCKS.AIR;
        }

        // Hotbar
        function createHotbar() {
            const hotbar = document.getElementById('hotbar');
            const blockIds = [1, 2, 3, 4, 5, 6, 8, 9];

            blockIds.forEach((id, index) => {
                const block = Object.values(BLOCKS).find(b => b.id === id);
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (index === 0 ? ' selected' : '');
                slot.innerHTML = `
                    <span class="slot-key">${index + 1}</span>
                    <span class="slot-icon">${block.icon}</span>
                    <span class="slot-count">${game.inventory[id] || 0}</span>
                `;
                slot.onclick = () => selectSlot(index);
                hotbar.appendChild(slot);
            });
        }

        function selectSlot(index) {
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach(s => s.classList.remove('selected'));
            slots[index].classList.add('selected');
            game.player.selectedSlot = index;

            const blockIds = [1, 2, 3, 4, 5, 6, 8, 9];
            const block = Object.values(BLOCKS).find(b => b.id === blockIds[index]);
            showTooltip(block.name);
        }

        function updateHotbar() {
            const slots = document.querySelectorAll('.hotbar-slot .slot-count');
            const blockIds = [1, 2, 3, 4, 5, 6, 8, 9];
            slots.forEach((slot, index) => {
                slot.textContent = game.inventory[blockIds[index]] || 0;
            });
            document.getElementById('blockCount').textContent =
                Object.values(game.inventory).reduce((a, b) => a + b, 0);
        }

        function showTooltip(text) {
            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = text;
            tooltip.classList.add('visible');
            setTimeout(() => tooltip.classList.remove('visible'), 1500);
        }

        // Event listeners
        function setupEventListeners() {
            document.getElementById('startBtn').addEventListener('click', startGame);

            document.addEventListener('keydown', e => {
                game.keys[e.key.toLowerCase()] = true;

                // Slot selection
                if (e.key >= '1' && e.key <= '8') {
                    selectSlot(parseInt(e.key) - 1);
                }

                // Sprint (double tap W)
                if (e.key.toLowerCase() === 'w') {
                    const now = Date.now();
                    if (now - game.player.lastWPress < 300) {
                        game.player.sprinting = true;
                    }
                    game.player.lastWPress = now;
                }
            });

            document.addEventListener('keyup', e => {
                game.keys[e.key.toLowerCase()] = false;
                if (e.key.toLowerCase() === 'w') {
                    game.player.sprinting = false;
                }
            });

            canvas.addEventListener('click', () => {
                if (!document.pointerLockElement) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                game.mouse.locked = document.pointerLockElement === canvas;
            });

            document.addEventListener('mousemove', e => {
                if (game.mouse.locked) {
                    game.player.yaw += e.movementX * 0.002;
                    game.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2,
                        game.player.pitch + e.movementY * 0.002));
                }
            });

            let mouseDown = false;
            canvas.addEventListener('mousedown', e => {
                if (!game.mouse.locked) return;
                mouseDown = true;

                if (e.button === 0) { // Left click - break
                    startBreakingBlock();
                } else if (e.button === 2) { // Right click - place
                    placeBlock();
                }
            });

            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
                stopBreakingBlock();
            });

            canvas.addEventListener('contextmenu', e => e.preventDefault());

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            canvas.requestPointerLock();

            // Generate initial chunks
            for (let x = -2; x <= 2; x++) {
                for (let z = -2; z <= 2; z++) {
                    generateChunk(x, z);
                }
            }

            // Find spawn position
            game.player.x = 0;
            game.player.z = 0;
            game.player.y = getTerrainHeight(0, 0) + 2;
        }

        function getTerrainHeight(x, z) {
            for (let y = 50; y >= 0; y--) {
                if (getBlock(x, y, z) !== BLOCKS.AIR.id) {
                    return y;
                }
            }
            return 15;
        }

        // Block breaking
        let breakingInterval = null;

        function startBreakingBlock() {
            const target = raycast();
            if (!target) return;

            const block = getBlockByPos(target);
            if (block.id === BLOCKS.AIR.id || block.hardness === 999) return;

            game.breakingBlock = target;
            game.breakProgress = 0;

            const progressBar = document.getElementById('blockBreakProgress');
            progressBar.classList.add('active');

            breakingInterval = setInterval(() => {
                game.breakProgress += 10 / (block.hardness * 10);
                const bar = progressBar.querySelector('.progress-bar');
                bar.style.width = Math.min(100, game.breakProgress * 100) + '%';

                if (game.breakProgress >= 1) {
                    breakBlock(target);
                    stopBreakingBlock();
                }
            }, 100);
        }

        function stopBreakingBlock() {
            if (breakingInterval) {
                clearInterval(breakingInterval);
                breakingInterval = null;
            }
            game.breakingBlock = null;
            game.breakProgress = 0;
            document.getElementById('blockBreakProgress').classList.remove('active');
        }

        function breakBlock(pos) {
            const blockType = getBlock(pos.x, pos.y, pos.z);
            if (blockType === BLOCKS.AIR.id) return;

            setBlock(pos.x, pos.y, pos.z, BLOCKS.AIR.id);
            game.inventory[blockType] = (game.inventory[blockType] || 0) + 1;
            updateHotbar();

            // Create particles
            createBlockParticles(pos, blockType);
            playBreakSound();
        }

        function placeBlock() {
            const target = raycast();
            if (!target || !target.adjacent) return;

            const { ax, ay, az } = target;
            const blockIds = [1, 2, 3, 4, 5, 6, 8, 9];
            const selectedBlockId = blockIds[game.player.selectedSlot];

            if ((game.inventory[selectedBlockId] || 0) <= 0) return;

            // Check if not placing in player position
            const px = Math.floor(game.player.x);
            const py = Math.floor(game.player.y);
            const pz = Math.floor(game.player.z);

            if ((ax === px && ay === py && az === pz) ||
                (ax === px && ay === py - 1 && az === pz)) {
                return;
            }

            setBlock(ax, ay, az, selectedBlockId);
            game.inventory[selectedBlockId]--;
            updateHotbar();
            playPlaceSound();
        }

        function raycast() {
            const maxDist = 6;
            const step = 0.05;

            const dirX = Math.cos(game.player.yaw) * Math.cos(game.player.pitch);
            const dirY = Math.sin(game.player.pitch);
            const dirZ = Math.sin(game.player.yaw) * Math.cos(game.player.pitch);

            let lastAir = null;

            for (let d = 0.1; d < maxDist; d += step) {
                const x = game.player.x + dirX * d;
                const y = game.player.y + 1.6 + dirY * d;
                const z = game.player.z + dirZ * d;

                const bx = Math.floor(x);
                const by = Math.floor(y);
                const bz = Math.floor(z);

                const block = getBlock(bx, by, bz);

                if (block !== BLOCKS.AIR.id) {
                    const result = { x: bx, y: by, z: bz };
                    if (lastAir) {
                        result.adjacent = true;
                        result.ax = lastAir.x;
                        result.ay = lastAir.y;
                        result.az = lastAir.z;
                    }
                    return result;
                }

                const key = `${bx},${by},${bz}`;
                const lastKey = lastAir ? `${lastAir.x},${lastAir.y},${lastAir.z}` : null;

                if (key !== lastKey) {
                    lastAir = { x: bx, y: by, z: bz };
                }
            }

            return null;
        }

        // Player physics
        function updatePlayer(dt) {
            const speed = (game.player.sprinting ? 10 : 6) * dt;
            const jumpSpeed = 8;

            // Movement
            let moveX = 0, moveZ = 0;

            if (game.keys['w']) {
                moveX += Math.cos(game.player.yaw);
                moveZ += Math.sin(game.player.yaw);
            }
            if (game.keys['s']) {
                moveX -= Math.cos(game.player.yaw);
                moveZ -= Math.sin(game.player.yaw);
            }
            if (game.keys['a']) {
                moveX += Math.cos(game.player.yaw - Math.PI / 2);
                moveZ += Math.sin(game.player.yaw - Math.PI / 2);
            }
            if (game.keys['d']) {
                moveX += Math.cos(game.player.yaw + Math.PI / 2);
                moveZ += Math.sin(game.player.yaw + Math.PI / 2);
            }

            const moveLen = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (moveLen > 0) {
                moveX = (moveX / moveLen) * speed;
                moveZ = (moveZ / moveLen) * speed;
            }

            // Flying
            if (game.keys[' ']) {
                if (game.player.onGround) {
                    game.player.vy = jumpSpeed;
                } else {
                    game.player.vy = 5;
                }
            } else if (game.keys['shift']) {
                game.player.vy = -5;
            } else {
                game.player.vy -= 25 * dt;
            }

            // Apply movement
            game.player.x += moveX;
            game.player.z += moveZ;
            game.player.y += game.player.vy * dt;

            // Collision
            game.player.onGround = false;

            if (getBlock(game.player.x, game.player.y - 0.1, game.player.z) !== BLOCKS.AIR.id) {
                game.player.y = Math.ceil(game.player.y);
                game.player.vy = 0;
                game.player.onGround = true;
            }

            if (game.player.y < -10) {
                game.player.y = getTerrainHeight(game.player.x, game.player.z) + 2;
                game.player.vy = 0;
            }

            // Generate nearby chunks
            const chunkX = Math.floor(game.player.x / game.chunkSize);
            const chunkZ = Math.floor(game.player.z / game.chunkSize);

            for (let x = chunkX - 1; x <= chunkX + 1; x++) {
                for (let z = chunkZ - 1; z <= chunkZ + 1; z++) {
                    generateChunk(x, z);
                }
            }
        }

        // Rendering
        function render() {
            // Sky color based on time
            const timeOfDay = (game.time % game.dayLength) / game.dayLength;
            let skyColor;

            if (timeOfDay < 0.25 || timeOfDay > 0.75) { // Night
                skyColor = '#1a1a2e';
            } else if (timeOfDay < 0.3) { // Sunrise
                const t = (timeOfDay - 0.25) / 0.05;
                skyColor = lerpColor('#1a1a2e', '#87CEEB', t);
            } else if (timeOfDay < 0.7) { // Day
                skyColor = '#87CEEB';
            } else { // Sunset
                const t = (timeOfDay - 0.7) / 0.05;
                skyColor = lerpColor('#87CEEB', '#FF6B6B', t * 0.5);
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, skyColor);
            gradient.addColorStop(0.5, lightenColor(skyColor, 10));
            gradient.addColorStop(1, lightenColor(skyColor, 20));
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get visible blocks
            const visibleBlocks = [];
            const px = Math.floor(game.player.x);
            const py = Math.floor(game.player.y);
            const pz = Math.floor(game.player.z);

            const yMin = Math.max(0, py - 12);
            const yMax = py + 12;
            const renderDistSq = game.renderDistance * game.renderDistance;

            for (let x = px - game.renderDistance; x <= px + game.renderDistance; x++) {
                for (let z = pz - game.renderDistance; z <= pz + game.renderDistance; z++) {
                    const distSq = (x - px) ** 2 + (z - pz) ** 2;
                    if (distSq > renderDistSq) continue;

                    for (let y = yMin; y <= yMax; y++) {
                        const block = getBlock(x, y, z);
                        if (block !== BLOCKS.AIR.id && isBlockVisible(x, y, z)) {
                            visibleBlocks.push({ x, y, z, type: block });
                        }
                    }
                }
            }

            // Sort by distance (back to front)
            visibleBlocks.sort((a, b) => {
                const distA = (a.x - game.player.x) ** 2 + (a.y - game.player.y) ** 2 + (a.z - game.player.z) ** 2;
                const distB = (b.x - game.player.x) ** 2 + (b.y - game.player.y) ** 2 + (b.z - game.player.z) ** 2;
                return distB - distA;
            });

            // Render blocks
            const maxBlocks = 1000;
            visibleBlocks.slice(0, maxBlocks).forEach(block => {
                renderBlock(block.x, block.y, block.z, block.type);
            });

            updateUI();
        }

        function isBlockVisible(x, y, z) {
            return (
                getBlock(x, y + 1, z) === BLOCKS.AIR.id ||
                getBlock(x, y - 1, z) === BLOCKS.AIR.id ||
                getBlock(x + 1, y, z) === BLOCKS.AIR.id ||
                getBlock(x - 1, y, z) === BLOCKS.AIR.id ||
                getBlock(x, y, z + 1) === BLOCKS.AIR.id ||
                getBlock(x, y, z - 1) === BLOCKS.AIR.id
            );
        }

        function renderBlock(x, y, z, type) {
            const block = Object.values(BLOCKS).find(b => b.id === type);
            if (!block || !block.color) return;

            const dx = x + 0.5 - game.player.x;
            const dy = y + 0.5 - game.player.y - 1.6;
            const dz = z + 0.5 - game.player.z;

            // Rotate
            const cosYaw = Math.cos(-game.player.yaw);
            const sinYaw = Math.sin(-game.player.yaw);
            let rx = dx * cosYaw - dz * sinYaw;
            let rz = dx * sinYaw + dz * cosYaw;
            let ry = dy;

            const cosPitch = Math.cos(-game.player.pitch);
            const sinPitch = Math.sin(-game.player.pitch);
            const tempY = ry * cosPitch - rz * sinPitch;
            rz = ry * sinPitch + rz * cosPitch;
            ry = tempY;

            if (rz < 0.1) return;

            // Project
            const fov = 1.5;
            const scale = (canvas.height * fov) / rz;
            const screenX = canvas.width / 2 + rx * scale;
            const screenY = canvas.height / 2 - ry * scale;
            const size = scale * 1;

            if (size < 2) return;
            if (screenX + size < 0 || screenX - size > canvas.width) return;
            if (screenY + size < 0 || screenY - size > canvas.height) return;

            // Lighting
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            const brightness = Math.max(0.5, 1 - (distance / game.renderDistance) * 0.4);

            // Time of day lighting
            const timeOfDay = (game.time % game.dayLength) / game.dayLength;
            let timeBrightness = 1;
            if (timeOfDay < 0.25 || timeOfDay > 0.75) {
                timeBrightness = 0.3; // Night
            } else if (timeOfDay < 0.3) {
                timeBrightness = 0.3 + ((timeOfDay - 0.25) / 0.05) * 0.7;
            } else if (timeOfDay > 0.7) {
                timeBrightness = 1 - ((timeOfDay - 0.7) / 0.05) * 0.7;
            }

            const finalBrightness = brightness * timeBrightness;

            // Determine face
            let color = block.color;
            if (ry < -0.5 && getBlock(x, y + 1, z) === BLOCKS.AIR.id) {
                color = block.topColor || block.color;
            } else if (rx > 0.3) {
                color = lightenColor(block.color, 5);
            } else if (rx < -0.3) {
                color = block.sideColor || darkenColor(block.color, 10);
            }

            // Water transparency
            if (type === BLOCKS.WATER.id) {
                ctx.globalAlpha = 0.7;
            }

            ctx.fillStyle = applyBrightness(color, finalBrightness);
            ctx.fillRect(screenX - size / 2, screenY - size / 2, size, size);

            ctx.strokeStyle = applyBrightness('#000000', finalBrightness * 0.4);
            ctx.lineWidth = Math.max(1, size * 0.02);
            ctx.strokeRect(screenX - size / 2, screenY - size / 2, size, size);

            ctx.globalAlpha = 1;
        }

        function applyBrightness(color, brightness) {
            const rgb = hexToRgb(color);
            const r = Math.floor(rgb.r * brightness);
            const g = Math.floor(rgb.g * brightness);
            const b = Math.floor(rgb.b * brightness);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function hexToRgb(hex) {
            if (hex.startsWith('rgb')) {
                const match = hex.match(/\d+/g);
                return { r: parseInt(match[0]), g: parseInt(match[1]), b: parseInt(match[2]) };
            }
            const num = parseInt(hex.replace('#', ''), 16);
            return {
                r: (num >> 16) & 255,
                g: (num >> 8) & 255,
                b: num & 255
            };
        }

        function lightenColor(color, percent) {
            const rgb = hexToRgb(color);
            const r = Math.min(255, rgb.r + percent * 2);
            const g = Math.min(255, rgb.g + percent * 2);
            const b = Math.min(255, rgb.b + percent * 2);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function darkenColor(color, percent) {
            const rgb = hexToRgb(color);
            const r = Math.max(0, rgb.r - percent * 2);
            const g = Math.max(0, rgb.g - percent * 2);
            const b = Math.max(0, rgb.b - percent * 2);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function lerpColor(color1, color2, t) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            const r = Math.floor(c1.r + (c2.r - c1.r) * t);
            const g = Math.floor(c1.g + (c2.g - c1.g) * t);
            const b = Math.floor(c1.b + (c2.b - c1.b) * t);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // UI updates
        function updateUI() {
            document.getElementById('position').textContent =
                `${Math.floor(game.player.x)}, ${Math.floor(game.player.y)}, ${Math.floor(game.player.z)}`;

            const target = raycast();
            const lookingAt = document.getElementById('lookingAt');
            if (target) {
                const block = getBlockByPos(target);
                lookingAt.textContent = block.name;
            } else {
                lookingAt.textContent = 'Sky';
            }

            // Time display
            const timeOfDay = (game.time % game.dayLength) / game.dayLength;
            const day = Math.floor(game.time / game.dayLength) + 1;
            const hours = Math.floor(timeOfDay * 24);
            const minutes = Math.floor((timeOfDay * 24 * 60) % 60);

            const timeIcon = document.getElementById('timeIcon');
            if (hours >= 6 && hours < 18) {
                timeIcon.textContent = hours < 12 ? 'üåÖ' : '‚òÄÔ∏è';
            } else {
                timeIcon.textContent = hours < 22 ? 'üåÜ' : 'üåô';
            }

            document.getElementById('timeDisplay').textContent =
                `Day ${day} - ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        // Particles
        function createBlockParticles(pos, blockType) {
            const block = Object.values(BLOCKS).find(b => b.id === blockType);
            if (!block) return;

            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = block.icon;
                particle.style.left = '50%';
                particle.style.top = '50%';
                particle.style.setProperty('--tx', `${(Math.random() - 0.5) * 100}px`);
                particle.style.setProperty('--ty', `${(Math.random() - 0.5) * 100}px`);
                document.getElementById('ui').appendChild(particle);

                setTimeout(() => particle.remove(), 1000);
            }
        }

        // Sound effects (simple beep using Web Audio API)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playBreakSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 200;
            oscillator.type = 'square';

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playPlaceSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 300;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
        }

        // FPS counter
        let frameCount = 0;
        let lastFpsUpdate = performance.now();

        function updateFPS() {
            frameCount++;
            const now = performance.now();

            if (now - lastFpsUpdate >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // Game loop
        let lastTime = performance.now();

        function gameLoop() {
            const currentTime = performance.now();
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            game.time += dt;

            updatePlayer(dt);
            render();
            updateFPS();

            requestAnimationFrame(gameLoop);
        }

        // Initialize
        setupEventListeners();
        createHotbar();
        updateHotbar();
        gameLoop();
    </script>
</body>
</html>